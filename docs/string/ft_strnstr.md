# ft_strnstr

> üîç Busca substring em string com limite de comprimento

---

**Categoria:** [Fun√ß√µes de String](./README.md)

**Reposit√≥rio:** [Libftosa](../../README.md)

**Arquivo:** `ft_strnstr.c`

---

## ‚ö†Ô∏è AVISO EDUCATIVO

**Este material √© puramente did√°tico e N√ÉO cont√©m implementa√ß√µes completas.**

Se voc√™ √© estudante da 42, use apenas para **entender conceitos** e desenvolva sua pr√≥pria solu√ß√£o.

---

## üìã SINOPSE

**Arquivo de Cabe√ßalho:**
```c
#include "libft.h"
```

**Prot√≥tipo:**
```c
char *ft_strnstr(const char *haystack, const char *needle, size_t len);
```

> üí° **Observa√ß√£o:** Busca apenas nos primeiros `len` caracteres da string principal.

---

## üìñ DESCRI√á√ÉO

A fun√ß√£o `ft_strnstr` localiza a primeira ocorr√™ncia da string `needle` dentro da string `haystack`, limitando a busca aos primeiros `len` caracteres de `haystack`.

### üéØ Objetivo
Encontrar substrings de forma segura e controlada, limitando o escopo da busca para evitar acessos desnecess√°rios √† mem√≥ria.

### üåç Aplica√ß√µes Reais
- **Parsing de protocolos:** Buscar headers HTTP limitados
- **An√°lise de logs:** Procurar padr√µes em linhas espec√≠ficas
- **Valida√ß√£o de entrada:** Verificar prefixos em dados de entrada
- **Busca em buffers:** Localizar padr√µes em dados bin√°rios

---

## üéØ PAR√ÇMETROS

| Par√¢metro | Tipo | Descri√ß√£o |
|-----------|------|-----------|
| `haystack` | `const char *` | String onde buscar (palheiro) |
| `needle` | `const char *` | String a ser encontrada (agulha) |
| `len` | `size_t` | N√∫mero m√°ximo de caracteres para buscar |

---

## ‚Ü©Ô∏è VALOR DE RETORNO

| Condi√ß√£o | Retorno | Descri√ß√£o |
|----------|---------|-----------|
| Encontrou | `char *` | Ponteiro para primeira ocorr√™ncia |
| N√£o encontrou | `NULL` | Substring n√£o existe no limite |
| Needle vazia | `haystack` | String vazia sempre "encontrada" |
| Par√¢metros inv√°lidos | `NULL` | haystack NULL ou len = 0 |

### üìä Exemplos de Comportamento

| haystack | needle | len | Resultado | Explica√ß√£o |
|----------|--------|-----|-----------|------------|
| "Hello World" | "World" | 11 | ‚Üí "World" | Encontrou dentro do limite |
| "Hello World" | "World" | 8 | `NULL` | Fora do limite (chars 1-8) |
| "Hello World" | "Hello" | 11 | ‚Üí "Hello World" | Encontrou no in√≠cio |
| "Test String" | "" | 5 | ‚Üí "Test String" | Needle vazia |
| "Short" | "LongNeedle" | 10 | `NULL` | Needle maior que haystack |

---

## üí° COMO ENTENDER O CONCEITO

### üßÆ Algoritmo B√°sico
```c
// 1. Verificar casos especiais (needle vazia, par√¢metros inv√°lidos)
// 2. Para cada posi√ß√£o i em haystack (at√© len):
//    a. Comparar needle[0..j] com haystack[i..i+j]
//    b. Se toda needle foi encontrada, retornar &haystack[i]
// 3. Se n√£o encontrou, retornar NULL
```

### üîç Visualiza√ß√£o da Busca
```
haystack: "Hello World Test"
needle:   "World"
len:      11

Posi√ß√£o:   0123456789AB
          "Hello World"  ‚Üê Busca limitada aos primeiros 11 chars
           ^^^^^         ‚Üê Tenta "Hello" != "World"
            ^^^^         ‚Üê Tenta "ello " != "World"  
             ^^^         ‚Üê Tenta "llo W" != "World"
              ^^         ‚Üê Tenta "lo Wo" != "World"
               ^         ‚Üê Tenta "o Wor" != "World"
                ^^^^     ‚Üê Tenta " Worl" != "World"
                 ^^^^    ‚Üê Tenta "World" == "World" ‚úÖ
```

### ‚ö†Ô∏è Diferen√ßa do strstr
```c
// strstr: busca em toda string
char *ptr1 = strstr("Hello World Test", "Test");
// ptr1 = "Test" ‚Üê Encontra

// strnstr: busca limitada
char *ptr2 = ft_strnstr("Hello World Test", "Test", 11);  
// ptr2 = NULL ‚Üê N√£o encontra (Test est√° na posi√ß√£o 12)
```

### üîç Casos Especiais Importantes
```c
// 1. Needle vazia sempre retorna haystack
ft_strnstr("Hello", "", 5) ‚Üí "Hello"

// 2. Haystack NULL retorna NULL
ft_strnstr(NULL, "test", 5) ‚Üí NULL

// 3. Len = 0 retorna NULL
ft_strnstr("Hello", "He", 0) ‚Üí NULL

// 4. Needle maior que limite
ft_strnstr("Hi", "Hello", 5) ‚Üí NULL
```

---

## üß™ EXEMPLO DE USO EDUCATIVO

```c
#include "libft.h"
#include <stdio.h>
#include <string.h>

void demonstrar_busca_basica(void)
{
    printf("=== BUSCA B√ÅSICA ===\n\n");
    
    const char *texto = "Aprendendo programa√ß√£o na 42";
    char *resultado;
    
    // Busca simples
    resultado = ft_strnstr(texto, "programa√ß√£o", strlen(texto));
    printf("Buscando 'programa√ß√£o': %s\n", 
           resultado ? resultado : "N√ÉO ENCONTRADO");
    
    // Busca no in√≠cio
    resultado = ft_strnstr(texto, "Aprendendo", strlen(texto));
    printf("Buscando 'Aprendendo': %s\n", 
           resultado ? resultado : "N√ÉO ENCONTRADO");
    
    // Busca inexistente
    resultado = ft_strnstr(texto, "Python", strlen(texto));
    printf("Buscando 'Python': %s\n", 
           resultado ? resultado : "N√ÉO ENCONTRADO");
    
    printf("\n");
}

void exemplo_limite_comprimento(void)
{
    printf("=== LIMITE DE COMPRIMENTO ===\n\n");
    
    const char *frase = "Estudar √© fundamental para crescer";
    char *resultado;
    
    printf("Frase completa: \"%s\"\n", frase);
    printf("Comprimento total: %zu\n\n", strlen(frase));
    
    // Busca dentro do limite
    resultado = ft_strnstr(frase, "fundamental", 20);
    printf("Busca 'fundamental' nos primeiros 20 chars: %s\n", 
           resultado ? "ENCONTRADO" : "N√ÉO ENCONTRADO");
    
    // Busca fora do limite  
    resultado = ft_strnstr(frase, "crescer", 20);
    printf("Busca 'crescer' nos primeiros 20 chars: %s\n", 
           resultado ? "ENCONTRADO" : "N√ÉO ENCONTRADO");
    
    // Mostra exatamente os primeiros 20 chars
    printf("\nPrimeiros 20 chars: \"");
    for (int i = 0; i < 20 && frase[i]; i++)
        printf("%c", frase[i]);
    printf("\"\n\n");
}

void exemplo_parsing_http(void)
{
    printf("=== PARSING HTTP ===\n\n");
    
    const char *header = "GET /api/users HTTP/1.1\r\nHost: example.com\r\nUser-Agent: curl";
    char *resultado;
    
    printf("Header HTTP:\n%s\n\n", header);
    
    // Buscar m√©todo HTTP (s√≥ no come√ßo)
    resultado = ft_strnstr(header, "GET", 10);
    printf("M√©todo encontrado: %s\n", 
           resultado ? "SIM" : "N√ÉO");
    
    // Buscar Host header
    resultado = ft_strnstr(header, "Host:", strlen(header));
    if (resultado)
    {
        printf("Host header: ");
        char *linha = resultado;
        while (*linha && *linha != '\r' && *linha != '\n')
            printf("%c", *linha++);
        printf("\n");
    }
    
    // Buscar User-Agent limitado
    resultado = ft_strnstr(header, "User-Agent", 50);
    printf("User-Agent nos primeiros 50 chars: %s\n", 
           resultado ? "ENCONTRADO" : "N√ÉO ENCONTRADO");
    
    printf("\n");
}

void exemplo_validacao_entrada(void)
{
    printf("=== VALIDA√á√ÉO DE ENTRADA ===\n\n");
    
    const char *comandos[] = {
        "list --all",
        "create new_file.txt", 
        "delete old_file.txt",
        "help commands",
        "exit program"
    };
    
    int total = sizeof(comandos) / sizeof(comandos[0]);
    
    // Verificar comandos v√°lidos
    const char *validos[] = {"list", "create", "delete", "help"};
    int total_validos = sizeof(validos) / sizeof(validos[0]);
    
    for (int i = 0; i < total; i++)
    {
        printf("Comando: \"%s\" ‚Üí ", comandos[i]);
        
        int encontrou = 0;
        for (int j = 0; j < total_validos; j++)
        {
            // Busca s√≥ no in√≠cio (primeiras 10 chars)
            char *resultado = ft_strnstr(comandos[i], validos[j], 10);
            if (resultado == comandos[i]) // Deve ser no in√≠cio
            {
                printf("‚úÖ V√ÅLIDO (%s)\n", validos[j]);
                encontrou = 1;
                break;
            }
        }
        
        if (!encontrou)
            printf("‚ùå INV√ÅLIDO\n");
    }
    
    printf("\n");
}

void demonstrar_casos_especiais(void)
{
    printf("=== CASOS ESPECIAIS ===\n\n");
    
    char *resultado;
    
    // Needle vazia
    resultado = ft_strnstr("Hello World", "", 5);
    printf("Needle vazia: %s\n", resultado ? resultado : "NULL");
    
    // Haystack vazio
    resultado = ft_strnstr("", "test", 5);
    printf("Haystack vazio: %s\n", resultado ? resultado : "NULL");
    
    // Limite zero
    resultado = ft_strnstr("Hello", "He", 0);
    printf("Limite zero: %s\n", resultado ? resultado : "NULL");
    
    // Needle maior que haystack
    resultado = ft_strnstr("Hi", "Hello", 10);
    printf("Needle > haystack: %s\n", resultado ? resultado : "NULL");
    
    // Padr√£o na borda do limite
    resultado = ft_strnstr("Hello", "lo", 5);
    printf("Padr√£o na borda (exato): %s\n", resultado ? resultado : "NULL");
    
    resultado = ft_strnstr("Hello", "lo", 4);
    printf("Padr√£o na borda (insuficiente): %s\n", resultado ? resultado : "NULL");
    
    printf("\n");
}

int main(void)
{
    printf("üîç DEMONSTRA√á√ÉO FT_STRNSTR\n");
    printf("==========================\n\n");
    
    demonstrar_busca_basica();
    exemplo_limite_comprimento();
    exemplo_parsing_http();
    exemplo_validacao_entrada();
    demonstrar_casos_especiais();
    
    printf("üí° LEMBRE-SE:\n");
    printf("   ‚Ä¢ strnstr limita a busca aos primeiros len chars\n");
    printf("   ‚Ä¢ Needle vazia sempre retorna haystack\n");
    printf("   ‚Ä¢ Retorna ponteiro para primeira ocorr√™ncia\n");
    printf("   ‚Ä¢ NULL se n√£o encontrar ou par√¢metros inv√°lidos\n");
    printf("   ‚Ä¢ Mais segura que strstr para buffers limitados\n");
    
    return (0);
}
```

**Sa√≠da esperada:**
```
üîç DEMONSTRA√á√ÉO FT_STRNSTR
==========================

=== BUSCA B√ÅSICA ===

Buscando 'programa√ß√£o': programa√ß√£o na 42
Buscando 'Aprendendo': Aprendendo programa√ß√£o na 42
Buscando 'Python': N√ÉO ENCONTRADO

=== LIMITE DE COMPRIMENTO ===

Frase completa: "Estudar √© fundamental para crescer"
Comprimento total: 34

Busca 'fundamental' nos primeiros 20 chars: ENCONTRADO
Busca 'crescer' nos primeiros 20 chars: N√ÉO ENCONTRADO

Primeiros 20 chars: "Estudar √© fundament"

=== PARSING HTTP ===

Header HTTP:
GET /api/users HTTP/1.1
Host: example.com
User-Agent: curl

M√©todo encontrado: SIM
Host header: Host: example.com
User-Agent nos primeiros 50 chars: N√ÉO ENCONTRADO

=== VALIDA√á√ÉO DE ENTRADA ===

Comando: "list --all" ‚Üí ‚úÖ V√ÅLIDO (list)
Comando: "create new_file.txt" ‚Üí ‚úÖ V√ÅLIDO (create)
Comando: "delete old_file.txt" ‚Üí ‚úÖ V√ÅLIDO (delete)
Comando: "help commands" ‚Üí ‚úÖ V√ÅLIDO (help)
Comando: "exit program" ‚Üí ‚ùå INV√ÅLIDO

=== CASOS ESPECIAIS ===

Needle vazia: Hello World
Haystack vazio: NULL
Limite zero: NULL
Needle > haystack: NULL
Padr√£o na borda (exato): lo
Padr√£o na borda (insuficiente): NULL

üí° LEMBRE-SE:
   ‚Ä¢ strnstr limita a busca aos primeiros len chars
   ‚Ä¢ Needle vazia sempre retorna haystack
   ‚Ä¢ Retorna ponteiro para primeira ocorr√™ncia
   ‚Ä¢ NULL se n√£o encontrar ou par√¢metros inv√°lidos
   ‚Ä¢ Mais segura que strstr para buffers limitados
```

---

## üìö CONCEITOS PARA ESTUDAR

### üîç Antes de Implementar
1. **Algoritmos de busca:** Como funciona a busca de substring
2. **Ponteiros:** Retorno de endere√ßos dentro de strings
3. **Limites de array:** Import√¢ncia de n√£o ultrapassar len
4. **Casos especiais:** Tratamento de entradas inv√°lidas

### üéØ Perguntas para Reflex√£o
- Por que strnstr √© mais segura que strstr?
- Como tratar o caso da needle vazia?
- O que acontece se needle for maior que o limite?
- Como garantir que n√£o acessamos mem√≥ria al√©m de len?

---

## üõ†Ô∏è ESTRAT√âGIAS DE IMPLEMENTA√á√ÉO

### üí≠ Abordagem 1: Dois Loops
```c
char *ft_strnstr(const char *haystack, const char *needle, size_t len)
{
    size_t i, j;
    
    if (!needle || *needle == '\0')
        return ((char *)haystack);
    if (!haystack || len == 0)
        return (NULL);
        
    i = 0;
    while (haystack[i] && i < len)
    {
        j = 0;
        while (needle[j] && haystack[i + j] && (i + j) < len
               && haystack[i + j] == needle[j])
            j++;
        if (needle[j] == '\0')
            return ((char *)&haystack[i]);
        i++;
    }
    return (NULL);
}
```

### üí≠ Abordagem 2: Com Helpers
```c
char *ft_strnstr(const char *haystack, const char *needle, size_t len)
{
    size_t needle_len;
    size_t i;
    
    if (!needle || !*needle)
        return ((char *)haystack);
    if (!haystack || len == 0)
        return (NULL);
        
    needle_len = ft_strlen(needle);
    if (needle_len > len)
        return (NULL);
        
    i = 0;
    while (haystack[i] && i <= len - needle_len)
    {
        if (ft_strncmp(&haystack[i], needle, needle_len) == 0)
            return ((char *)&haystack[i]);
        i++;
    }
    return (NULL);
}
```

### üîß Dicas de Implementa√ß√£o
- **Casos especiais primeiro:** Tratar needle vazia e par√¢metros NULL
- **Verificar limites:** Sempre garantir que (i + j) < len
- **Otimiza√ß√£o:** Se needle √© maior que len, retornar NULL imediatamente
- **Depend√™ncias:** Pode usar ft_strlen e ft_strncmp para simplificar

---

## üéì EXERC√çCIOS PARA PRATICAR

### ü•â N√≠vel Iniciante
1. Implemente strnstr b√°sica com dois loops
2. Teste com strings simples e diferentes valores de len
3. Verifique todos os casos especiais

### ü•à N√≠vel Intermedi√°rio
1. Otimize usando ft_strlen e ft_strncmp
2. Adicione prote√ß√£o contra overflow nos √≠ndices
3. Crie vers√£o case-insensitive (strncasestr)

### ü•á N√≠vel Avan√ßado
1. Implemente algoritmo de busca mais eficiente (KMP ou Boyer-Moore)
2. Crie vers√£o para wide characters (wcsnstr)
3. Adicione suporte a express√µes regulares simples

---

## üîó FUN√á√ïES RELACIONADAS

### üß† Mesma Categoria - String
- [`ft_strlen`](ft_strlen.md) - Pode ser usada para otimiza√ß√µes
- [`ft_strncmp`](ft_strncmp.md) - Pode ser usada para comparar substrings
- [`ft_strchr`](ft_strchr.md) - Busca caractere √∫nico
- [`ft_strrchr`](ft_strrchr.md) - Busca caractere do final

### üîÑ Fun√ß√µes de Busca
- `strstr` - Busca em string completa
- `strcasestr` - Busca case-insensitive
- `memmem` - Busca em mem√≥ria bruta

### üìù Aplica√ß√µes Pr√°ticas
- [`ft_split`](../additional/ft_split.md) - Usa conceitos de busca
- Parsing de protocolos
- Valida√ß√£o de entrada

---

## üìñ MATERIAL DE APOIO

### üìö Recursos Did√°ticos
- [üîç String Searching Algorithms](../../resources/string_search.md)
- [üìè Bounded String Operations](../../resources/bounded_strings.md)
- [üõ°Ô∏è Safe String Handling](../../resources/safe_strings.md)

### üîó Refer√™ncias Externas
- Manual do C: `man strnstr`
- [GNU C Library - String Search](https://www.gnu.org/software/libc/manual/html_node/Search-Functions.html)
- [String Algorithms - Substring Search](https://www.cs.princeton.edu/courses/archive/cos126/fall06/lectures/strings.pdf)

---

## ‚úçÔ∏è NOTAS PESSOAIS

### üìù Meu Processo de Aprendizado

**Dificuldades encontradas:**
- [ ] Entender como limitar a busca corretamente
- [ ] Tratar o caso da needle vazia
- [ ] Garantir que n√£o acesso mem√≥ria al√©m de len
- [ ] Implementar a l√≥gica de compara√ß√£o aninhada

**Descobertas importantes:**
- [ ] strnstr √© fundamental para parsing seguro
- [ ] Needle vazia tem comportamento especial
- [ ] Limites devem ser verificados em ambos os loops
- [ ] Retorno de ponteiro permite acesso ao contexto

**Testes que fiz:**
- [ ] Busca b√°sica em diferentes posi√ß√µes
- [ ] Casos com limite menor que a string
- [ ] Needle vazia e par√¢metros NULL
- [ ] Padr√µes na borda do limite

---
<div align="center">

[‚Üê Fun√ß√£o Anterior: ft_strlcat](ft_strlcat.md) | [Pr√≥xima Fun√ß√£o: ft_strdup ‚Üí](ft_strdup.md)

üî§ [Fun√ß√µes de String](./README.md) | [üìö Voltar ao √çndice](../../README.md)

---

**üõ°Ô∏è Material Educativo - Libftosa**  
*Desenvolvendo conceitos, n√£o copiando solu√ß√µes*

</div>
