# ft_strncmp

> üîç Compara duas strings at√© um limite espec√≠fico de caracteres

---

**Categoria:** [Fun√ß√µes de String](./README.md)

**Reposit√≥rio:** [Libftosa](../../README.md)

**Arquivo:** `ft_strncmp.c`

---

## ‚ö†Ô∏è AVISO EDUCATIVO

**Este material √© puramente did√°tico e N√ÉO cont√©m implementa√ß√µes completas.**

Se voc√™ √© estudante da 42, use apenas para **entender conceitos** e desenvolva sua pr√≥pria solu√ß√£o.

---

## üìã SINOPSE

**Arquivo de Cabe√ßalho:**
```c
#include "libft.h"
```

**Prot√≥tipo:**
```c
int ft_strncmp(const char *s1, const char *s2, size_t n);
```

> üí° **Observa√ß√£o:** Compara apenas os primeiros `n` caracteres, evitando compara√ß√µes desnecess√°rias.

---

## üìñ DESCRI√á√ÉO

A fun√ß√£o `ft_strncmp` compara lexicograficamente as strings `s1` e `s2` at√© no m√°ximo `n` caracteres, retornando um valor que indica a rela√ß√£o entre elas.

### üéØ Objetivo
Permitir compara√ß√£o parcial de strings, √∫til para prefixos, valida√ß√µes limitadas e otimiza√ß√µes.

### üåç Aplica√ß√µes Reais
- **Verifica√ß√£o de prefixos:** Checar se string come√ßa com determinado texto
- **Comandos de shell:** Comparar comandos parciais (`ls`, `list`, `l`)
- **Valida√ß√£o de protocolos:** HTTP, FTP, etc. (`http://`, `ftp://`)
- **Compara√ß√£o segura:** Evitar buffer overflow em compara√ß√µes

---

## üéØ PAR√ÇMETROS

| Par√¢metro | Tipo | Descri√ß√£o |
|-----------|------|-----------|
| `s1` | `const char *` | Primeira string para compara√ß√£o |
| `s2` | `const char *` | Segunda string para compara√ß√£o |
| `n` | `size_t` | N√∫mero m√°ximo de caracteres a comparar |

---

## ‚Ü©Ô∏è VALOR DE RETORNO

| Condi√ß√£o | Retorno | Descri√ß√£o |
|----------|---------|-----------|
| s1 < s2 | `< 0` | s1 √© lexicograficamente menor |
| s1 == s2 | `0` | Strings s√£o iguais nos primeiros n caracteres |
| s1 > s2 | `> 0` | s1 √© lexicograficamente maior |

### üìä Exemplos de Comportamento

| s1 | s2 | n | Resultado | Explica√ß√£o |
|----|----|----|-----------|------------|
| `"abc"` | `"abc"` | 3 | 0 | Strings id√™nticas |
| `"abc"` | `"abd"` | 3 | < 0 | 'c' < 'd' na posi√ß√£o 2 |
| `"abc"` | `"ab"` | 3 | > 0 | s1 tem mais caracteres |
| `"abc"` | `"abd"` | 2 | 0 | Iguais nos 2 primeiros caracteres |
| `"abc"` | `"xyz"` | 0 | 0 | n=0, n√£o compara nada |

---

## üí° COMO ENTENDER O CONCEITO

### üî§ Compara√ß√£o Lexicogr√°fica
```
Lexicogr√°fica = ordem do dicion√°rio
"apple" < "banana" < "cherry"

Baseada nos valores ASCII:
'A' = 65, 'a' = 97
'A' < 'a' (mai√∫scula vem antes)
```

### üÜö Diferen√ßa do strcmp
```c
// strcmp: compara TODA a string
strcmp("hello world", "hello universe");  // Compara 13+ caracteres

// strncmp: compara apenas N caracteres
strncmp("hello world", "hello universe", 5);  // S√≥ "hello"
// Resultado: 0 (iguais nos 5 primeiros)
```

### üîç Processo de Compara√ß√£o
```
s1 = "programming"
s2 = "program"
n = 7

Posi√ß√£o:  0 1 2 3 4 5 6
s1:      'p r o g r a m' (continua...)
s2:      'p r o g r a m' (termina)
         ‚Üë ‚Üë ‚Üë ‚Üë ‚Üë ‚Üë ‚Üë
Compara:  = = = = = = =

Resultado: s1[7] = 'm', s2[7] = '\0'
'm' > '\0', ent√£o s1 > s2 ‚Üí retorno > 0
```

### ‚ö†Ô∏è Casos Especiais
```c
// n = 0: n√£o compara nada
strncmp("abc", "xyz", 0);  // ‚Üí 0

// Uma string termina antes de n
strncmp("hi", "hello", 5);  // s1 termina no √≠ndice 2
// Compara: 'h'='h', 'i'='e' ‚Üí 'i' > 'e' ‚Üí resultado > 0

// Strings id√™nticas mas uma √© mais longa
strncmp("test", "testing", 4);  // ‚Üí 0 (iguais nos 4 primeiros)
strncmp("test", "testing", 5);  // ‚Üí 't' vs '\0' ‚Üí resultado < 0
```

---

## üß™ EXEMPLO DE USO EDUCATIVO

```c
#include "libft.h"
#include <stdio.h>
#include <string.h>

void demonstrar_comparacao_basica(void)
{
    printf("=== COMPARA√á√ïES B√ÅSICAS ===\n\n");
    
    char *str1 = "programming";
    char *str2 = "program";
    
    // Compara√ß√µes com diferentes valores de n
    printf("str1: \"%s\"\n", str1);
    printf("str2: \"%s\"\n\n", str2);
    
    for (int n = 1; n <= 8; n++)
    {
        int result = ft_strncmp(str1, str2, n);
        printf("ft_strncmp(str1, str2, %d) = %2d ", n, result);
        
        if (result < 0)
            printf("(str1 < str2)\n");
        else if (result > 0)
            printf("(str1 > str2)\n");
        else
            printf("(str1 == str2)\n");
    }
    printf("\n");
}

void exemplo_prefixos(void)
{
    printf("=== VERIFICA√á√ÉO DE PREFIXOS ===\n\n");
    
    char *urls[] = {
        "https://google.com",
        "http://example.org",
        "ftp://files.server.com",
        "file:///local/path",
        NULL
    };
    
    char *protocols[] = {"http://", "https://", "ftp://", NULL};
    
    for (int i = 0; urls[i]; i++)
    {
        printf("URL: %s\n", urls[i]);
        
        for (int j = 0; protocols[j]; j++)
        {
            int len = strlen(protocols[j]);
            int result = ft_strncmp(urls[i], protocols[j], len);
            
            printf("  %s: %s\n", protocols[j], 
                   result == 0 ? "‚úÖ MATCH" : "‚ùå NO");
        }
        printf("\n");
    }
}

void exemplo_comandos_shell(void)
{
    printf("=== COMANDOS DE SHELL (PREFIXOS) ===\n\n");
    
    char *input[] = {"ls", "list", "l", "cat", "ca", "copy", NULL};
    char *commands[] = {"ls", "list", "cat", "copy", NULL};
    
    for (int i = 0; input[i]; i++)
    {
        printf("Entrada: \"%s\"\n", input[i]);
        
        for (int j = 0; commands[j]; j++)
        {
            int input_len = strlen(input[i]);
            int result = ft_strncmp(input[i], commands[j], input_len);
            
            if (result == 0)
                printf("  ‚Üí Poss√≠vel match: \"%s\"\n", commands[j]);
        }
        printf("\n");
    }
}

void exemplo_casos_especiais(void)
{
    printf("=== CASOS ESPECIAIS ===\n\n");
    
    // n = 0
    printf("n = 0 (n√£o compara nada):\n");
    printf("ft_strncmp(\"abc\", \"xyz\", 0) = %d\n\n", 
           ft_strncmp("abc", "xyz", 0));
    
    // Strings vazias
    printf("Strings vazias:\n");
    printf("ft_strncmp(\"\", \"\", 5) = %d\n", 
           ft_strncmp("", "", 5));
    printf("ft_strncmp(\"abc\", \"\", 3) = %d\n", 
           ft_strncmp("abc", "", 3));
    printf("ft_strncmp(\"\", \"abc\", 3) = %d\n\n", 
           ft_strncmp("", "abc", 3));
    
    // Caracteres especiais
    printf("Caracteres especiais:\n");
    printf("ft_strncmp(\"ABC\", \"abc\", 3) = %d (mai√∫scula < min√∫scula)\n",
           ft_strncmp("ABC", "abc", 3));
    printf("ft_strncmp(\"123\", \"12a\", 3) = %d (n√∫mero < letra)\n",
           ft_strncmp("123", "12a", 3));
    printf("\n");
}

void comparar_com_original(void)
{
    printf("=== COMPARA√á√ÉO COM STRNCMP ORIGINAL ===\n\n");
    
    struct {
        char *s1;
        char *s2;
        size_t n;
    } tests[] = {
        {"hello", "hello", 5},
        {"hello", "world", 5},
        {"test", "testing", 4},
        {"test", "testing", 6},
        {"ABC", "abc", 3},
        {"", "", 0},
        {NULL, NULL, 0}
    };
    
    for (int i = 0; tests[i].s1; i++)
    {
        int orig = strncmp(tests[i].s1, tests[i].s2, tests[i].n);
        int mine = ft_strncmp(tests[i].s1, tests[i].s2, tests[i].n);
        
        printf("s1=\"%s\", s2=\"%s\", n=%zu\n", 
               tests[i].s1, tests[i].s2, tests[i].n);
        printf("  Original: %d, ft_strncmp: %d %s\n\n",
               orig, mine, 
               ((orig < 0 && mine < 0) || 
                (orig > 0 && mine > 0) || 
                (orig == 0 && mine == 0)) ? "‚úÖ" : "‚ùå");
    }
}

int main(void)
{
    printf("üß™ DEMONSTRA√á√ÉO FT_STRNCMP\n");
    printf("==========================\n\n");
    
    demonstrar_comparacao_basica();
    exemplo_prefixos();
    exemplo_comandos_shell();
    exemplo_casos_especiais();
    comparar_com_original();
    
    printf("üí° LEMBRE-SE:\n");
    printf("   ‚Ä¢ Compara apenas os primeiros n caracteres\n");
    printf("   ‚Ä¢ Retorno: <0, 0, >0 (menor, igual, maior)\n");
    printf("   ‚Ä¢ Para no primeiro \\0 ou diferen√ßa\n");
    printf("   ‚Ä¢ √ötil para prefixos e valida√ß√µes\n");
    
    return (0);
}
```

**Sa√≠da esperada:**
```
üß™ DEMONSTRA√á√ÉO FT_STRNCMP
==========================

=== COMPARA√á√ïES B√ÅSICAS ===

str1: "programming"
str2: "program"

ft_strncmp(str1, str2, 1) =  0 (str1 == str2)
ft_strncmp(str1, str2, 2) =  0 (str1 == str2)
ft_strncmp(str1, str2, 3) =  0 (str1 == str2)
ft_strncmp(str1, str2, 4) =  0 (str1 == str2)
ft_strncmp(str1, str2, 5) =  0 (str1 == str2)
ft_strncmp(str1, str2, 6) =  0 (str1 == str2)
ft_strncmp(str1, str2, 7) =  0 (str1 == str2)
ft_strncmp(str1, str2, 8) = 109 (str1 > str2)

=== VERIFICA√á√ÉO DE PREFIXOS ===

URL: https://google.com
  http://: ‚ùå NO
  https://: ‚úÖ MATCH
  ftp://: ‚ùå NO

URL: http://example.org
  http://: ‚úÖ MATCH
  https://: ‚ùå NO
  ftp://: ‚ùå NO

=== COMANDOS DE SHELL (PREFIXOS) ===

Entrada: "ls"
  ‚Üí Poss√≠vel match: "ls"

Entrada: "list"
  ‚Üí Poss√≠vel match: "list"

Entrada: "l"
  ‚Üí Poss√≠vel match: "ls"
  ‚Üí Poss√≠vel match: "list"

üí° LEMBRE-SE:
   ‚Ä¢ Compara apenas os primeiros n caracteres
   ‚Ä¢ Retorno: <0, 0, >0 (menor, igual, maior)
   ‚Ä¢ Para no primeiro \0 ou diferen√ßa
   ‚Ä¢ √ötil para prefixos e valida√ß√µes
```

---

## üìö CONCEITOS PARA ESTUDAR

### üîç Antes de Implementar
1. **Ordem lexicogr√°fica:** Como strings s√£o ordenadas
2. **Valores ASCII:** Tabela de caracteres e seus c√≥digos
3. **Unsigned char casting:** Por que √© importante
4. **Compara√ß√£o limitada:** Diferen√ßa de strcmp

### üéØ Perguntas para Reflex√£o
- Por que retornamos diferen√ßa entre caracteres?
- Como tratar caracteres com sinal negativo?
- O que acontece quando n > comprimento das strings?
- Por que n=0 sempre retorna 0?

---

## üõ†Ô∏è ESTRAT√âGIAS DE IMPLEMENTA√á√ÉO

### üí≠ Abordagem 1: Cl√°ssica com Loop
```c
int ft_strncmp(const char *s1, const char *s2, size_t n)
{
    size_t i;
    
    i = 0;
    while (i < n && (s1[i] || s2[i]))
    {
        if (s1[i] != s2[i])
            return ((unsigned char)s1[i] - (unsigned char)s2[i]);
        i++;
    }
    return (0);
}
```

### üí≠ Abordagem 2: Ponteiros com Incremento
```c
int ft_strncmp(const char *s1, const char *s2, size_t n)
{
    while (n > 0 && (*s1 || *s2))
    {
        if (*s1 != *s2)
            return ((unsigned char)*s1 - (unsigned char)*s2);
        s1++;
        s2++;
        n--;
    }
    return (0);
}
```

### üí≠ Abordagem 3: Verifica√ß√£o Antecipada
```c
int ft_strncmp(const char *s1, const char *s2, size_t n)
{
    if (n == 0)
        return (0);
        
    while (n-- > 0)
    {
        if (*s1 != *s2 || *s1 == '\0')
            return ((unsigned char)*s1 - (unsigned char)*s2);
        s1++;
        s2++;
    }
    return (0);
}
```

### üîß Dicas de Implementa√ß√£o
- **Cast para unsigned char:** Evitar problemas com caracteres negativos
- **Verificar n=0:** Retornar 0 imediatamente
- **Parar em \0:** Mesmo que n n√£o tenha sido atingido
- **Diferen√ßa aritm√©tica:** Retornar s1[i] - s2[i], n√£o apenas -1/0/1

---

## üéì EXERC√çCIOS PARA PRATICAR

### ü•â N√≠vel Iniciante
1. Implemente ft_strncmp b√°sica
2. Teste com strings id√™nticas de diferentes tamanhos
3. Compare com strncmp original

### ü•à N√≠vel Intermedi√°rio
1. Teste com caracteres especiais e acentuados
2. Implemente vers√£o case-insensitive (strncasecmp)
3. Crie testes para todos os casos especiais

### ü•á N√≠vel Avan√ßado
1. Otimize para comparar palavras inteiras por vez
2. Implemente vers√£o que ignora espa√ßos
3. Crie ft_strnrcmp (compara do final para in√≠cio)

---

## üîó FUN√á√ïES RELACIONADAS

### üß† Mesma Categoria - Compara√ß√£o
- `strcmp` - Compara strings completas
- `strcasecmp` - Compara ignorando mai√∫sculas/min√∫sculas
- `strncasecmp` - Vers√£o limitada da anterior

### üîÑ Fun√ß√µes de Busca
- [`ft_strchr`](ft_strchr.md) - Busca caractere na string
- [`ft_strrchr`](ft_strrchr.md) - Busca caractere do final
- [`ft_strnstr`](ft_strnstr.md) - Busca substring limitada

### üìù Fun√ß√µes de Mem√≥ria
- [`ft_memcmp`](../memory/ft_memcmp.md) - Compara blocos de mem√≥ria

---

## üìñ MATERIAL DE APOIO

### üìö Recursos Did√°ticos
- [üî§ Ordena√ß√£o Lexicogr√°fica](../../resources/lexicographic_order.md)
- [üî¢ Tabela ASCII](../../resources/ascii_table.md)
- [üéØ Compara√ß√£o de Strings](../../resources/string_comparison.md)

### üîó Refer√™ncias Externas
- Manual do C: `man strncmp`
- [C Reference - String Comparison](https://en.cppreference.com/w/c/string/byte/strncmp)

---

## ‚úçÔ∏è NOTAS PESSOAIS

### üìù Meu Processo de Aprendizado

**Dificuldades encontradas:**
- [ ] Entender ordem lexicogr√°fica
- [ ] Por que cast para unsigned char
- [ ] Diferen√ßa entre retornar -1/0/1 vs diferen√ßa real
- [ ] Casos especiais (n=0, strings vazias)

**Descobertas importantes:**
- [ ] strncmp √© fundamental para prefixos
- [ ] √ötil para valida√ß√£o de protocolos
- [ ] Evita compara√ß√µes desnecess√°rias
- [ ] Base para muitas opera√ß√µes de string

**Testes que fiz:**
- [ ] Strings com caracteres especiais
- [ ] Diferentes valores de n
- [ ] Compara√ß√£o com vers√£o original
- [ ] Casos de prefixos reais

---
<div align="center">

[‚Üê Fun√ß√£o Anterior: ft_strrchr](ft_strrchr.md) | [Pr√≥xima Fun√ß√£o: ft_strlcpy ‚Üí](ft_strlcpy.md)

üî§ [Fun√ß√µes de String](./README.md) | [üìö Voltar ao √çndice](../../README.md)

---

**üõ°Ô∏è Material Educativo - Libftosa**  
*Desenvolvendo conceitos, n√£o copiando solu√ß√µes*

</div>
